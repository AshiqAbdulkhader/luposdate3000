package lupos.s09physicalOperators.multiinput
import kotlin.jvm.JvmField
import lupos.s00misc.EOperatorID
import lupos.s00misc.ESortPriority
import lupos.s00misc.Partition
import lupos.s00misc.SanityCheck
import lupos.s00misc.XMLElement
import lupos.s03resultRepresentation.ResultSetDictionaryExt
import lupos.s04logicalOperators.IOPBase
import lupos.s04logicalOperators.IQuery
import lupos.s04logicalOperators.iterator.ColumnIterator
import lupos.s04logicalOperators.iterator.ColumnIteratorChildIterator
import lupos.s04logicalOperators.iterator.IteratorBundle
import lupos.s09physicalOperators.POPBase
//SELECT ?var_s ?var_p1 ?var_o1 ?var_p2 ?var_o2 WHERE {?var_s ?var_p1 ?var_o1 . ?var_s ?var_p2 ?var_o2 .}
class POPJoinMergeCodeGenExample(query: IQuery, projectedVariables: List<String>, childA: IOPBase, childB: IOPBase, @JvmField val optional: Boolean) : POPBase(query, projectedVariables, EOperatorID.POPJoinMergeID, "POPJoinMerge", arrayOf(childA, childB), ESortPriority.JOIN) {
    override fun getPartitionCount(variable: String): Int {
        return if (children[0].getProvidedVariableNames().contains(variable)) {
            if (children[1].getProvidedVariableNames().contains(variable)) {
                SanityCheck.check { children[0].getPartitionCount(variable) == children[1].getPartitionCount(variable) }
                children[0].getPartitionCount(variable)
            } else {
                children[0].getPartitionCount(variable)
            }
        } else {
            if (children[1].getProvidedVariableNames().contains(variable)) {
                children[1].getPartitionCount(variable)
            } else {
                throw Exception("unknown variable $variable")
            }
        }
    }
    override fun toSparql(): String = children[0].toSparql() + children[1].toSparql()
    override /*suspend*/ fun toXMLElement(): XMLElement = super.toXMLElement().addAttribute("optional", "" + optional)
    override fun cloneOP(): IOPBase = POPJoinMerge(query, projectedVariables, children[0].cloneOP(), children[1].cloneOP(), optional)
    override fun equals(other: Any?): Boolean = other is POPJoinMerge && optional == other.optional && children[0] == other.children[0] && children[1] == other.children[1]
    internal class ColumnIteratorChildIteratorImpl(
        @JvmField val column_in_left_s: ColumnIterator,
        @JvmField val column_in_right_s: ColumnIterator,
        @JvmField val column_in_left_p1: ColumnIterator,
        @JvmField val column_in_left_o1: ColumnIterator,
        @JvmField val column_in_right_p2: ColumnIterator,
        @JvmField val column_in_right_o2: ColumnIterator,
        @JvmField val column_out_p1: ColumnIterator,
        @JvmField val column_out_o1: ColumnIterator,
        @JvmField val column_out_p2: ColumnIterator,
        @JvmField val column_out_o2: ColumnIterator,
        @JvmField val column_out_s: ColumnIteratorChildIterator,
        @JvmField val key0: IntArray,
        @JvmField val key1: IntArray
    ) : ColumnIteratorChildIterator() {
        @JvmField
        var key_left_s = key[0]
        @JvmField
        var key_right_s = key[1]
        @JvmField
        var data_left_p1 = IntArray(100)
        @JvmField
        var data_left_o1 = IntArray(100)
        @JvmField
        var data_right_p2 = IntArray(100)
        @JvmField
        var data_right_o2 = IntArray(100)
        @JvmField
        var localNextI = 0
        @JvmField
        var localNextJ = 0
        @JvmField
        var localNextCounta = 0
        @JvmField
        var localNextCountb = 0
        @JvmField
        var localNextKeycopy = 0
        @JvmField
        var localCloseI = 0
        @JvmField
        var skipO0 = 0
        @JvmField
        var skipO1 = 0
        @JvmField
        var sipbuf = IntArray(2)
        /*suspend*/ private inline fun __close() {
            if (label != 0) {
                column_out_p1.closeOnNoMoreElements()
                column_out_o1.closeOnNoMoreElements()
                column_out_p2.closeOnNoMoreElements()
                column_out_o2.closeOnNoMoreElements()
                column_out_s.closeOnNoMoreElements()
                column_in_left_s.close()
                column_in_right_s.close()
                column_in_left_p1.close()
                column_in_left_o1.close()
                column_in_right_p2.close()
                column_in_right_o2.close()
                _close()
            }
        }
        override /*suspend*/ fun close() {
            __close()
        }
        override /*suspend*/ fun next(): Int {
            return nextHelper(
                {
                    if (key_left_s != ResultSetDictionaryExt.nullValue && key_right_s != ResultSetDictionaryExt.nullValue) {
                        loop@ while (true) {
// first join column
                            if (key_left_s != key_right_s) {
                                var skip0 = 0
                                var skip1 = 0
                                while (key_left_s != key_right_s) {
                                    if (key_left_s < key_right_s) {
                                        column_in_left_s.nextSIP(key_right_s, sipbuf)
                                        key_left_s = sipbuf[1]
                                        skip0 += sipbuf[0]
                                        skipO0 += sipbuf[0]
                                        skip0++
                                        skipO0++
                                        SanityCheck.check { key_left_s != ResultSetDictionaryExt.undefValue }
                                        if (key_left_s == ResultSetDictionaryExt.nullValue) {
                                            __close()
                                            break@loop
                                        }
                                    } else {
                                        column_in_right_s.nextSIP(key_left_s, sipbuf)
                                        key_right_s = sipbuf[1]
                                        skip1 += sipbuf[0]
                                        skipO1 += sipbuf[0]
                                        skip1++
                                        skipO1++
                                        SanityCheck.check { key_right_s != ResultSetDictionaryExt.undefValue }
                                        if (key_right_s == ResultSetDictionaryExt.nullValue) {
                                            __close()
                                            break@loop
                                        }
                                    }
                                }
                            }
// safe the join columns
                            localNextKeycopy = key_left_s
// the only-A columns
                            localNextCounta = 0
                            loop2@ while (true) {
                                if (localNextCounta >= data_left_p1.size) {
                                    var x = data_left_p1
                                    var d = IntArray(localNextCounta * 2)
                                    localNextJ = 0
                                    while (localNextJ < localNextCounta) {
                                        d[localNextJ] = x[localNextJ]
                                        localNextJ++
                                    }
                                    data_left_p1 = d
                                    x = data_left_o1
                                    d = IntArray(localNextCounta * 2)
                                    localNextJ = 0
                                    while (localNextJ < localNextCounta) {
                                        d[localNextJ] = x[localNextJ]
                                        localNextJ++
                                    }
                                    data_left_o1 = d
                                }
                                data_left_p1[localNextCounta] = column_in_left_p1.skipSIP(skipO0)
                                data_left_o1[localNextCounta] = column_in_left_o1.skipSIP(skipO0)
                                skipO0 = 0
                                localNextCounta++
                                key_left_s = column_in_left_s.next()
                                SanityCheck.check { key_left_s != ResultSetDictionaryExt.undefValue }
                                if (key_left_s != localNextKeycopy) {
                                    break@loop2
                                }
                            }
                        }
// the only-B columns
                        localNextCountb = 0
                        loop2@ while (true) {
                            if (localNextCountb >= data_right_p2.size) {
                                var x = data_right_p2
                                var d = IntArray(localNextCountb * 2)
                                localNextJ = 0
                                while (localNextJ < localNextCountb) {
                                    d[localNextJ] = x[localNextJ]
                                    localNextJ++
                                }
                                data_right_p2 = d
                                x = data_right_o2
                                d = IntArray(localNextCountb * 2)
                                localNextJ = 0
                                while (localNextJ < localNextCountb) {
                                    d[localNextJ] = x[localNextJ]
                                    localNextJ++
                                }
                                data_right_o2 = d
                            }
                            data_right_p2[localNextCountb] = column_in_right_p2.skipSIP(skipO1)
                            data_right_o2[localNextCountb] = column_in_right_o2.skipSIP(skipO1)
                            skipO1 = 0
                            localNextCountb++
                            key_right_s = column_in_right_s.next()
                            SanityCheck.check { key_right_s != ResultSetDictionaryExt.undefValue }
                            if (key_right_s != localNextKeycopy) {
                                break@loop2
                            }
                        }
                        POPJoin.crossProduct(arrayOf(data_left_p1, data_left_o1), arrayOf(data_right_p2, data_right_o2), arrayOf(localNextKeycopy), arrayOf(column_out_p1, column_out_o1), arrayOf(column_out_p2, column_out_o2), arrayOf(column_out_s), localNextCounta, localNextCountb)
                        break@loop
                    }
                } else {
                __close()
            }
        },
        { __close() }
        )
    }
}
override /*suspend*/ fun evaluate(parent: Partition): IteratorBundle {
    SanityCheck.check { !optional }
    // setup columns
    SanityCheck {
        for (v in children[0].getProvidedVariableNames()) {
            getPartitionCount(v)
        }
        for (v in children[1].getProvidedVariableNames()) {
            getPartitionCount(v)
        }
    }
    SanityCheck.println { "$uuid open $classname" }
    val child0 = children[0].evaluate(parent)
    val child1 = children[1].evaluate(parent)
    val columnsINO0 = mutableListOf<ColumnIterator>()
    val columnsINO1 = mutableListOf<ColumnIterator>()
    val columnsINJ0 = mutableListOf<ColumnIterator>()
    val columnsINJ1 = mutableListOf<ColumnIterator>()
    val columnsOUT0 = mutableListOf<ColumnIteratorChildIterator>()
    val columnsOUT1 = mutableListOf<ColumnIteratorChildIterator>()
    val columnsOUTJ = mutableListOf<ColumnIteratorChildIterator>()
    val outIterators = mutableListOf<Pair<String, Int>>() // Key_in_outMap, which_outIteratorsCounter (J,O0,O1,none)
    val outMap = mutableMapOf<String, ColumnIterator>()
    val tmp = mutableListOf<String>()
    tmp.addAll(children[1].getProvidedVariableNames())
    for (name in children[0].getProvidedVariableNames()) {
        if (tmp.contains(name)) {
            if (projectedVariables.contains(name)) {
                outIterators.add(Pair(name, 0))
                columnsINJ0.add(0, child0.columns[name]!!)
                columnsINJ1.add(0, child1.columns[name]!!)
            } else {
                columnsINJ0.add(child0.columns[name]!!)
                columnsINJ1.add(child1.columns[name]!!)
            }
            tmp.remove(name)
        } else {
            outIterators.add(Pair(name, 1))
            columnsINO0.add(child0.columns[name]!!)
        }
    }
    for (name in tmp) {
        outIterators.add(Pair(name, 2))
        columnsINO1.add(child1.columns[name]!!)
    }
    SanityCheck.check { columnsINJ0.size > 0 }
    SanityCheck.check { columnsINJ0.size == columnsINJ1.size }
    val emptyColumnsWithJoin = outIterators.size == 0
    if (emptyColumnsWithJoin) {
        outIterators.add(Pair("", 3))
    }
    val key0 = IntArray(columnsINJ0.size)
    val key1 = IntArray(columnsINJ1.size)
    for ((first, second) in outIterators) {
        val iterator = ColumnIteratorChildIteratorImpl(columnsINJ0, columnsINJ1, columnsINO0, columnsINO1, columnsOUT0, columnsOUT1, columnsOUTJ, key0, key1)
        when (second) {
            0 -> {
                outMap[first] = iterator
                columnsOUTJ.add(iterator)
            }
            1 -> {
                outMap[first] = iterator
                columnsOUT0.add(iterator)
            }
            2 -> {
                outMap[first] = iterator
                columnsOUT1.add(iterator)
            }
            3 -> {
                columnsOUTJ.add(iterator)
            }
        }
    }
    val res: IteratorBundle
    if (emptyColumnsWithJoin) {
        res = IteratorBundleImpl(columnsINJ0, columnsINJ1, columnsOUTJ[0])
        for (it in columnsINO0) {
            it.close()
        }
        for (it in columnsINO1) {
            it.close()
        }
    } else {
        res = IteratorBundle(outMap)
    }
    for (i in 0 until columnsINJ0.size) {
        key0[i] = columnsINJ0[i].next()
    }
    for (i in 0 until columnsINJ1.size) {
        key1[i] = columnsINJ1[i].next()
    }
    return res
}
}
