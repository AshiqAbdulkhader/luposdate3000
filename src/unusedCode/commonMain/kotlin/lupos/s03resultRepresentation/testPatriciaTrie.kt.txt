import kotlin.jvm.JvmField
 val PAGE_SIZE_IN_BYTES = 8192
 val ARRAY_LIST_BLOCK_CAPACITY = 1048576
 val B_TREE_BRANCHING_FACTOR = 512
 val MAX_TRIPLES_DURING_TEST = -1
    class MyMapStringIntPatriciaTrieNode() {
        var parent = 0
        var str = ""
        var data = IntArray(0)
        /* data stores offsets in str, child-values, child-pointers  */
    }



class MyMapStringIntPatriciaTrieDouble() {
    @JvmField
    var debugfilename = ""

    @JvmField
    val undefinedValue = -1

    @JvmField
    var root: MyMapStringIntPatriciaTrieNode ?=null

    @JvmField
    var rootValue: Int = undefinedValue
    var size: Int = 0
        get() = allOutNodes!!.size

    @JvmField
    var allNodes : MyListGeneric<MyMapStringIntPatriciaTrieNode>?=null

    @JvmField
    var allOutNodes : MyListInt?=null//index in allNodes!!

    @JvmField
    var allOutOffsets : MyListInt?=null//index in allNodes!!Childs
    fun clear() {
        root = MyMapStringIntPatriciaTrieNode()
        rootValue = undefinedValue
        allOutNodes!!.clear()
        allOutOffsets!!.clear()
        allNodes!!.clear()
        allNodes!!.add(root!!)
    }

    fun _init() {
	root=MyMapStringIntPatriciaTrieNode()
allNodes = MyListGeneric<MyMapStringIntPatriciaTrieNode>()
allOutNodes = MyListInt()
allOutOffsets = MyListInt()
        allNodes!!.add(root!!)
    }

    operator fun get(key: Int): String {
        if (key == rootValue) {
            return ""
        }
        var nodeIdx = allOutNodes!![key]
        var childIdx = allOutOffsets!![key]
        var res = ""
        var node = allNodes!![nodeIdx]
        while (true) {
            val childKeyStart = node.data[childIdx]
            val childKeyEnd: Int
            val childCount = node.data.size / 3
            if (childIdx == childCount - 1) {
                childKeyEnd = node.str.length
            } else {
                childKeyEnd = node.data[childIdx + 1]
            }
            res = node.str.substring(childKeyStart, childKeyEnd) + res
            if (nodeIdx == node.parent) {
                return res
            }
            childIdx = 0
            val parent = allNodes!![node.parent]
            val parentChildCount = parent.data.size / 3
            val parentChildCount2 = parentChildCount + parentChildCount
            while (parent.data[parentChildCount2 + childIdx] != nodeIdx) {
                childIdx++
            }
            nodeIdx = node.parent
            node = parent
        }
    }

    fun debug() {
    }

    /*inline*/ fun walkInternal(_key: String, create: Boolean): Int {
        if (_key == "") {
            if (create && rootValue == undefinedValue) {
                rootValue = allOutNodes!!.size
                allOutNodes!!.add(-1)
                allOutOffsets!!.add(-1)
            }
            return rootValue
        } else {
            var key = _key
            var nextNode = root!!
            var nextNodeIdx = 0
            loop@ while (true) {
                val node = nextNode
                val nodeIdx = nextNodeIdx
                var childCount = node.data.size / 3
                for (childIdx in 0 until childCount) {
                    if (node.str[node.data[childIdx]] == key[0]) {
                        val childNodeIdx = node.data[childCount + childCount + childIdx]
                        val childNode = allNodes!![childNodeIdx]
                        var childKeyStart = node.data[childIdx]
                        var childKeyEnd: Int
                        if (childIdx == childCount - 1) {
                            childKeyEnd = node.str.length
                        } else {
                            childKeyEnd = node.data[childIdx + 1]
                        }
                        var childKey = node.str.substring(childKeyStart, childKeyEnd)
                        var commonKey = key.commonPrefixWith(childKey)
                        if (commonKey.length == key.length && commonKey.length == childKey.length) {
                            var result = node.data[childCount + childIdx]
                            if (result == undefinedValue) {
                                result = allOutNodes!!.size
                                node.data[childCount + childIdx] = result
                                allOutNodes!!.add(nodeIdx)
                                allOutOffsets!!.add(childIdx)
                            }
                            return result
                        } else if (commonKey.length == childKey.length) {
                            if (childNodeIdx != 0) {
                                nextNode = childNode
                                nextNodeIdx = childNodeIdx
                                key = key.substring(childKey.length, key.length)
                                continue@loop
                            } else {
                                var result = undefinedValue
                                if (create) {
                                    //previous key was a prefix of the new key
                                    val newNode = MyMapStringIntPatriciaTrieNode()
                                    val newNodeIdx = allNodes!!.size
                                    allNodes!!.add(newNode)
                                    result = allOutNodes!!.size
                                    allOutNodes!!.add(newNodeIdx)
                                    allOutOffsets!!.add(0)
                                    newNode.parent = nodeIdx
                                    newNode.data = intArrayOf(0, result, 0)
                                    newNode.str = key.substring(commonKey.length, key.length)
                                    node.data[childCount + childCount + childIdx] = newNodeIdx
                                    size++
                                }
                                return result
                            }
                        } else {
                            var result = undefinedValue
                            if (create) {
                                val otherKey = childKey.substring(commonKey.length, childKey.length)
                                val otherChildIdx = node.data[childCount + childCount + childIdx]
                                val otherResult = node.data[childCount + childIdx]
                                val newNode = MyMapStringIntPatriciaTrieNode()
                                val newNodeIdx = allNodes!!.size
                                newNode.parent = nodeIdx
                                allNodes!!.add(newNode)
                                result = allOutNodes!!.size
                                if (otherChildIdx != 0) {
                                    val otherChild = allNodes!![otherChildIdx]
                                    otherChild.parent = newNodeIdx
                                }
                                if (commonKey.length == key.length) {
                                    allOutNodes!!.add(nodeIdx)
                                    allOutOffsets!!.add(childIdx)
                                    //new key is a prefix of the old key
                                    newNode.str = otherKey
                                    newNode.data = intArrayOf(0, otherResult, otherChildIdx)
                                    if (otherResult != undefinedValue) {
                                        allOutNodes!![otherResult] = newNodeIdx
                                        allOutOffsets!![otherResult] = 0
                                    }
                                    node.data[childCount + childCount + childIdx] = newNodeIdx
                                    node.data[childCount + childIdx] = result
                                    node.str = node.str.substring(0, childKeyStart) + commonKey + node.str.substring(childKeyEnd, node.str.length)
                                    for (j in childIdx + 1 until childCount) {
                                        node.data[j] -= otherKey.length
                                    }
                                } else {
                                    allOutNodes!!.add(newNodeIdx)
                                    allOutOffsets!!.add(0)
                                    val newKey = key.substring(commonKey.length, key.length)
                                    //both keys share a common prefix - both need to be changed
                                    newNode.str = newKey + otherKey
                                    newNode.data = intArrayOf(0, newKey.length, result, otherResult, 0, otherChildIdx)
                                    if (otherResult != undefinedValue) {
                                        allOutNodes!![otherResult] = newNodeIdx
                                        allOutOffsets!![otherResult] = 1
                                    }
                                    node.data[childCount + childCount + childIdx] = newNodeIdx
                                    node.data[childCount + childIdx] = undefinedValue
                                    node.str = node.str.substring(0, childKeyStart) + commonKey + node.str.substring(childKeyEnd, node.str.length)
                                    for (j in childIdx + 1 until childCount) {
                                        node.data[j] -= otherKey.length
                                    }
                                }
                                size++
                            }
                            return result
                        }
                    }
                }
                var result = undefinedValue
                if (create) {
                    result = allOutNodes!!.size
                    allOutNodes!!.add(nodeIdx)
                    allOutOffsets!!.add(childCount)
                    val data = IntArray(node.data.size + 3)
                    for (i in 0 until childCount) {
                        data[i] = node.data[i]
                        data[childCount + 1 + i] = node.data[childCount + i]
                        data[childCount + childCount + 2 + i] = node.data[childCount + childCount + i]
                    }
                    data[childCount] = node.str.length
                    data[childCount + childCount + 1] = result
                    node.data = data
                    node.str += key
                    size++
                }
                return result
            }
        }
    }

    operator fun get(key: String): Int? {
        var res = walkInternal(key, false)
        if (res == undefinedValue) {
            return null
        }
        return res
    }

    operator fun set(key: String, value: Int): Unit = throw Exception("")
    fun getOrCreate(key: String): Int {
        var res = walkInternal(key, true)
        return res
    }

    fun appendAssumeSorted(key: String, value: Int): Unit = throw Exception("")
    fun safeToFile(filename: String) {
        debugfilename = filename
        File(filename).dataOutputStream { out ->
            out.writeInt(rootValue)
            out.writeInt(allNodes!!.size)
//writeing allNodes!! -->>
            val nodeIterator = allNodes!!.iterator()
            var idx = 0
            while (nodeIterator.hasNext()) {
                val node = nodeIterator.next()
                for (c in node.str) {
                    out.writeChar(c.toInt())
                }
                out.writeChar(0)
                out.writeShort(node.data.size)
                for (i in 0 until node.data.size) {
                    out.writeInt(node.data[i])
                }
                idx++
            }
//writeing allNodes!! <<--
        }
    }

    fun loadFromFile(filename: String) {
        debugfilename = filename
        clear()
        File(filename).dataInputStream { fis ->
            rootValue = fis.readInt()
            if (rootValue != undefinedValue) {
                size++
            }
            val allNodesSize = fis.readInt()
            for (counter in 0 until allNodesSize) {
                var node: MyMapStringIntPatriciaTrieNode
                if (allNodes!!.size < counter) {
                    node = MyMapStringIntPatriciaTrieNode()
                    allNodes!![counter] = node
                } else {
                    node = allNodes!![counter]
                }
                var c = fis.readChar()
                while (c.toInt() != 0) {
                    node.str += c
                    c = fis.readChar()
                }
                val nodeDataSize = fis.readShort()
                node.data = IntArray(nodeDataSize.toInt())
                val valueOffset = nodeDataSize / 3
                val childOffset = valueOffset * 2
                for (i in 0 until nodeDataSize) {
                    val value = fis.readInt()
                    node.data[i] = value
                    if (i >= valueOffset) {
                        if (i < childOffset) {
                            while (value > allOutNodes!!.size) {
                                allOutNodes!!.add(0)
                                allOutOffsets!!.add(0)
                            }
                            if (value != undefinedValue) {
                                allOutNodes!![value] = counter
                                allOutOffsets!![value] = i - valueOffset
                            }
                        } else {
                            while (value >= allNodes!!.size) {
                                allNodes!!.add(MyMapStringIntPatriciaTrieNode())
                            }
                            if (value != 0) {
                                allNodes!![value].parent = counter
                            }
                        }
                    }
                }
            }
        }
        root = allNodes!![0]
    }
}
