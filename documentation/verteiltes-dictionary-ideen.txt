assuming dictionary mapping all values to int

Dictionary Layout Ideas:
option 1:
 - gateway node (there may be multiple, but than again these are required to be synchronized)
 - advantages:
   - just one copy of global-dictionary required (bestcase for space)
   - less network communikation, because only ids get ever transferred (better for network)
   - transactions are easy, because only this node needs to have any locking implemented (better for locking)
   - local dictionary implementation can be used as it is right now for the distributed case too
   - allows all hashing-strategies, because the gateway node knows all string representations
   - dedicated dictionary nodes may have the advantage of better cache management, because these dedicated nodes "know" what Strings are needed often
   - should be simple to implement - dictionary related things are just never send over network
 - disadvantages:
   - break the p2p semantic
   - single point of failure
   - all requests go over the same node (speed limitation by one node)
   - import-phase (insert and delete as well)
     - single node must import all the data alone
     - or single node assigns ids, and then another node redistributes the data based on int-id-hashing-distribution
   - one node is "different" from all the others
   - if there are arithmetik expressions, all data must be moved to the gateway node or at least ask this node lots of times
     - if there are many queries with arithmetic expressions, this is a huge problem
     - gateway node can be asked once per query, for the translation of Int->String, and than cache it until the end of this query

option 2:
 - fully synchronized dictionary on every node
 - advantages:
   - full independence of any other node
   - queries can be submitted to any known node
     - allows all hashing-strategies here too, because the string representation is available everywhere
   - from the implementation point of view, this is a broadcast every time, the dictionary changes
   - for the current benchmarks this means one broadcast directly after the import, and nothing during evaluation
 - disadvantages:
   - maximum copies of dictionary (worstcase for space)
   - changes in the store need to be send to every other node on every new data in the dictionary - even if the data is only stored at some nodes
   - requires synchronisation code
   - requires locking to avoid duplicate Int-IDs
     - alternatively a global instance to "assign" Int-ID-ranges to nodes, which can than be used by that node to define a new value
     - problem: multiple nodes may assign the same value to different IDs .... .
     - possible solution: only a single node is allowed to create dictionary entries ... which comes back to the problem of single point of failure/single special node

option 3:
 - local dictionaries only -> communikation with strings only
 - advantages:
   - each dictionary is small - faster dictionary search requests
   - full independence of any other node
   - queries can be submitted to any known node
   - supports any hashing strategy on every node, because every node known all required String representations
 - disadvantags:
   - commonly used typed are stored at serveral nodes with different Int-IDs, because the nodes dont know from each other
 - blank nodes are special and need to be handled differently
   - option 3a:
     - store BNode Strings too, which wastes space, but every node can have its own prefixString(IP-Address), therefore BNodes can be shared in the Database, and each node can create new BNodes
     - this should be simple to implement
   - option 3b:
     - Each node obtains a "range" in which it is free to define BNodes
     - This requires a global instance to manage the BNode ranges
     - this is not really "local dictionaries only" anymore
     - during query evaluation communikation, these bnodes are assumed to be already mapped to global space-ids

regardless of the global dictionary:
 - if there are "bind xyz as abc" or "group by xyz as abc"
   - there must be some kind of sharing query-local dictionaries
   - during a running queries the "new" int->string mappings for bnodes are known (additionally to all other value types) - and required
   - these intermediate result dictionaries can (and must?!?) be transfered during the query
